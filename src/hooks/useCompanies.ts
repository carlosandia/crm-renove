import { useState, useCallback, useEffect } from 'react';
import { supabase } from '../lib/supabase';
import { logger } from '../lib/logger';
import { Company, CompanyAdmin } from '../types/Company';
import { useAuth } from '../providers/AuthProvider';
import { showSuccessToast, showErrorToast } from './useToast';

export const useCompanies = () => {
  const [companies, setCompanies] = useState<Company[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isPolling, setIsPolling] = useState(false);
  
  // üîß CORRE√á√ÉO: Usar padr√£o b√°sico Supabase Authentication
  const { user } = useAuth();
  
  const formatDateBrasilia = useCallback((dateString: string) => {
    try {
      const date = new Date(dateString);
      return date.toLocaleString('pt-BR', {
        timeZone: 'America/Sao_Paulo',
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    } catch (error) {
      return 'Data inv√°lida';
    }
  }, []);

  /**
   * üîß CORRE√á√ÉO CR√çTICA: Busca de empresas corrigida para super_admin
   */
  const fetchCompanies = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      console.log('üîç [useCompanies] Iniciando busca de empresas...');

      let companiesData: Company[] = [];

      // ‚úÖ CORRE√á√ÉO: Usar Supabase direto com autentica√ß√£o b√°sica
      console.log('üîÑ [useCompanies] Usando Supabase...');
      try {
        const { data: supabaseData, error: supabaseError } = await supabase
          .from('companies')
          .select('*')
          .order('created_at', { ascending: false });
        
        if (supabaseError) {
          throw new Error(`Supabase error: ${supabaseError.message}`);
        }
        
        companiesData = supabaseData || [];
        console.log(`‚úÖ [useCompanies] Supabase: ${companiesData.length} empresas encontradas`);
      } catch (supabaseError: any) {
        console.error('‚ùå [useCompanies] Supabase falhou:', supabaseError.message);
        throw supabaseError;
      }

      // üîß Processar empresas buscando admin via queries separadas
      const companiesWithAdmin = await Promise.all(
        companiesData.map(async (company: Company) => {
          try {
            // Buscar admin da empresa via Supabase
            const { data: adminData, error: adminError } = await supabase
              .from('users')
              .select('id, first_name, last_name, email, created_at, is_active')
              .eq('role', 'admin')
              .eq('tenant_id', company.id)
              .maybeSingle();

            let admin: CompanyAdmin | undefined;
            
            if (!adminError && adminData) {
              // Determinar status de ativa√ß√£o
              let activationStatus: 'pending' | 'sent' | 'activated' | 'expired' | 'inactive' = 'pending';
              let invitationToken: string | undefined = undefined;
              let invitationSentAt: string | undefined = undefined;
              
              // 1. Se usu√°rio est√° ativo, considerar como ativado
              if (adminData.is_active) {
                activationStatus = 'activated';
              } else {
                // 2. Se usu√°rio est√° inativo, considerar como inativo (n√£o pendente)
                activationStatus = 'inactive';
                
                // OPCIONAL: Verificar se existe convite pendente apenas para casos especiais
                try {
                  const { data: invitationData } = await supabase
                    .from('admin_invitations')
                    .select('invitation_token, sent_at, status, expires_at')
                    .eq('email', adminData.email)
                    .eq('company_id', company.id)
                    .order('created_at', { ascending: false })
                    .limit(1)
                    .maybeSingle();

                  if (invitationData) {
                    invitationToken = invitationData.invitation_token;
                    invitationSentAt = invitationData.sent_at;
                    
                    // S√≥ alterar status se h√° convite pendente/enviado (casos especiais)
                    if (invitationData.status === 'expired') {
                      activationStatus = 'expired';
                    } else if (invitationData.status === 'pending' || invitationData.status === 'sent') {
                      activationStatus = 'pending';
                    }
                  }
                } catch (invitationError) {
                  console.warn(`‚ö†Ô∏è Erro ao buscar convite para "${adminData.email}":`, invitationError);
                  // Manter 'inactive' como padr√£o
                }
              }
              
              admin = {
                id: adminData.id,
                name: `${adminData.first_name} ${adminData.last_name}`.trim(),
                email: adminData.email,
                role: 'admin',
                tenant_id: company.id,
                is_active: adminData.is_active,
                created_at: adminData.created_at,
                activation_status: activationStatus,
                invitation_id: invitationToken,
                invitation_sent_at: invitationSentAt,
                invitation_expires_at: invitationSentAt && invitationSentAt !== 'null' && !isNaN(new Date(invitationSentAt).getTime()) ? 
                  new Date(new Date(invitationSentAt).getTime() + 48 * 60 * 60 * 1000).toISOString() : 
                  undefined,
                resend_count: 0
              };
            }

            return {
              ...company,
              admin
            } as Company;
          } catch (error) {
            console.error(`‚ùå Erro ao processar admin da empresa "${company.name}":`, error);
            return company as Company;
          }
        })
      );

      setCompanies(companiesWithAdmin);
      console.log(`üéâ [useCompanies] ${companiesWithAdmin.length} empresas processadas com sucesso`);

    } catch (error: any) {
      console.error('‚ùå [useCompanies] Erro ao carregar empresas:', error);
      setError(error instanceof Error ? error.message : 'Erro desconhecido');
      setCompanies([]);
    } finally {
      setLoading(false);
    }
  }, []);

  const toggleCompanyStatus = useCallback(async (company: Company) => {
    const novoStatus = !company.is_active;
    const acao = novoStatus ? 'ativar' : 'desativar';
    
    try {
      logger.info(`${acao.charAt(0).toUpperCase() + acao.slice(1)}ando empresa:`, company.name);

      if (!novoStatus) {
        // DESATIVAR: empresa + todos usu√°rios
        console.log(`üîê [toggleCompanyStatus] SEGURAN√áA: Desativando empresa e todos usu√°rios "${company.name}" (tenant_id: ${company.id})`);
        
        // Executar opera√ß√µes em paralelo para melhor performance
        const [companyResult, usersResult] = await Promise.all([
          // Desativar empresa
          supabase
            .from('companies')
            .update({
              is_active: false,
              segment: `${company.industry} | ${company.city}/${company.state} | Leads:${company.expected_leads_monthly} Vendas:${company.expected_sales_monthly} Seg:${company.expected_followers_monthly} | ATIVO:false`,
              updated_at: new Date().toISOString()
            })
            .eq('id', company.id),
          
          // Desativar todos usu√°rios (admin e member) da empresa
          supabase
            .from('users')
            .update({ 
              is_active: false,
              updated_at: new Date().toISOString()
            })
            .eq('tenant_id', company.id)
            .neq('role', 'super_admin') // Nunca desativar super_admin
        ]);
        
        if (companyResult.error) {
          throw new Error(`Erro ao desativar empresa: ${companyResult.error.message}`);
        }
        
        if (usersResult.error) {
          throw new Error(`Erro ao desativar usu√°rios: ${usersResult.error.message}`);
        }
        
        console.log(`‚úÖ [toggleCompanyStatus] Empresa desativada e ${usersResult.count || 0} usu√°rios desativados com sucesso`);
        
      } else {
        // ATIVAR: empresa + usu√°rios + convites
        console.log(`üöÄ [toggleCompanyStatus] ATIVA√á√ÉO AUTOM√ÅTICA: Ativando empresa e todos usu√°rios "${company.name}" (tenant_id: ${company.id})`);
        
        // Executar opera√ß√µes em paralelo para melhor performance
        const [companyResult, usersResult, invitationsResult] = await Promise.all([
          // Ativar empresa
          supabase
            .from('companies')
            .update({
              is_active: true,
              segment: `${company.industry} | ${company.city}/${company.state} | Leads:${company.expected_leads_monthly} Vendas:${company.expected_sales_monthly} Seg:${company.expected_followers_monthly} | ATIVO:true`,
              updated_at: new Date().toISOString()
            })
            .eq('id', company.id),
          
          // Ativar todos usu√°rios admin/member da empresa
          supabase
            .from('users')
            .update({ 
              is_active: true,
              updated_at: new Date().toISOString()
            })
            .eq('tenant_id', company.id)
            .neq('role', 'super_admin'), // super_admin j√° est√° sempre ativo
          
          // Marcar convites como aceitos/ativados
          supabase
            .from('admin_invitations')
            .update({ 
              status: 'accepted',
              accepted_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            })
            .eq('company_id', company.id)
            .in('status', ['pending', 'sent', 'expired']) // Apenas convites n√£o aceitos
        ]);
        
        if (companyResult.error) {
          throw new Error(`Erro ao ativar empresa: ${companyResult.error.message}`);
        }
        
        if (usersResult.error) {
          throw new Error(`Erro ao ativar usu√°rios: ${usersResult.error.message}`);
        }
        
        // Erro em convites n√£o √© cr√≠tico (pode n√£o existir)
        if (invitationsResult.error) {
          console.warn(`‚ö†Ô∏è [toggleCompanyStatus] Aviso ao atualizar convites: ${invitationsResult.error.message}`);
        }
        
        console.log(`‚úÖ [toggleCompanyStatus] Empresa ativada, ${usersResult.count || 0} usu√°rios ativados e ${invitationsResult.count || 0} convites marcados como aceitos`);
      }

      await fetchCompanies();
      
      const statusMessage = !novoStatus 
        ? `‚úÖ Empresa "${company.name}" foi desativada e todos usu√°rios perderam acesso!`
        : `‚úÖ Empresa "${company.name}" foi ativada e todos usu√°rios foram automaticamente ativados!`;
      
      logger.success(`Empresa "${company.name}" ${acao === 'ativar' ? 'ativada' : 'desativada'} com sucesso`);
      
      return { success: true, message: statusMessage };
      
    } catch (error) {
      logger.error(`Erro ao ${acao} empresa:`, error);
      const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';
      return { success: false, message: `‚ùå Erro ao ${acao} empresa: ${errorMessage}` };
    }
  }, [fetchCompanies]);

  const deleteCompany = useCallback(async (company: Company) => {
    try {
      console.log(`üóëÔ∏è [useCompanies] Excluindo empresa: ${company.name}`);
      
      // ‚úÖ CORRE√á√ÉO: Usar Supabase diretamente
      const { error } = await supabase
        .from('companies')
        .update({ is_active: false })
        .eq('id', company.id);
      
      if (!error) {
        console.log(`‚úÖ [useCompanies] Empresa exclu√≠da com sucesso: ${company.name}`);
        await fetchCompanies(); // Atualizar dados
        showSuccessToast('Empresa exclu√≠da', `Empresa "${company.name}" exclu√≠da com sucesso!`);
      } else {
        console.error(`‚ùå [useCompanies] Erro ao excluir empresa:`, error);
        showErrorToast('Erro ao excluir', `Erro ao excluir empresa: ${error.message}`);
      }
    } catch (error) {
      console.error(`‚ùå [useCompanies] Erro de conex√£o:`, error);
      showErrorToast('Erro de conex√£o', `${error instanceof Error ? error.message : 'Erro desconhecido'}`);
    }
  }, [fetchCompanies]);

  const resendActivationEmail = useCallback(async (company: Company) => {
    if (!company.admin) {
      return { success: false, message: 'Admin n√£o encontrado' };
    }

    try {
      console.log(`üìß [useCompanies] Reenviando email para: ${company.admin.email}`);
      
      // ‚úÖ MIGRADO: Usar autentica√ß√£o b√°sica Supabase
      const { data: { user: currentUser }, error: userError } = await supabase.auth.getUser();
      
      if (userError || !currentUser) {
        return { success: false, message: 'Usu√°rio n√£o autenticado' };
      }

      // Verificar se √© super_admin
      const userRole = currentUser.user_metadata?.role;
      if (userRole !== 'super_admin') {
        return { success: false, message: 'Acesso negado: apenas super_admin pode reenviar convites' };
      }
      
      // ‚úÖ B√ÅSICO: Obter token do usu√°rio autenticado  
      const { data: { session } } = await supabase.auth.getSession();
      if (!session?.access_token) {
        return { success: false, message: 'Token de autentica√ß√£o n√£o dispon√≠vel' };
      }
      
      // Fazer requisi√ß√£o usando URL relativa (proxy Vite)
      const response = await fetch('/api/admin-invitations/send', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${session.access_token}`
        },
        body: JSON.stringify({
          adminEmail: company.admin.email,
          adminName: company.admin.name,
          companyName: company.name,
          companyId: company.id
        })
      });

      const result = await response.json();
      
      if (result.success) {
        console.log(`‚úÖ [useCompanies] Email reenviado com sucesso:`, result.messageId);
        await fetchCompanies(); // Atualizar dados
        return { 
          success: true, 
          message: `‚úÖ Email de ativa√ß√£o reenviado para ${company.admin.email}` 
        };
      } else {
        console.error(`‚ùå [useCompanies] Erro ao reenviar email:`, result.error);
        return { 
          success: false, 
          message: `‚ùå Erro ao reenviar email: ${result.error}` 
        };
      }
    } catch (error) {
      console.error(`‚ùå [useCompanies] Erro de conex√£o:`, error);
      return { 
        success: false, 
        message: `‚ùå Erro de conex√£o: ${error instanceof Error ? error.message : 'Erro desconhecido'}` 
      };
    }
  }, [fetchCompanies]);

  useEffect(() => {
    fetchCompanies();
    
    // Listener para refresh autom√°tico ap√≥s ativa√ß√£o
    const handleAdminActivated = (event: CustomEvent) => {
      console.log('üîÑ [useCompanies] Admin ativado detectado, atualizando lista:', event.detail);
      setTimeout(() => {
        fetchCompanies();
      }, 1000);
    };

    // ‚úÖ OTIMIZA√á√ÉO: Listener √∫nico e simplificado para cria√ß√£o de empresa
    const handleCompanyCreated = (event: CustomEvent) => {
      console.log('üîÑ [useCompanies] Empresa criada detectada:', event.detail);
      console.log('üìã [useCompanies] Executando refresh da lista...');
      
      // ‚úÖ OTIMIZA√á√ÉO: Refresh simples sem force clear
      fetchCompanies().then(() => {
        console.log('‚úÖ [useCompanies] Lista atualizada com sucesso');
      }).catch(error => {
        console.error('‚ùå [useCompanies] Erro na atualiza√ß√£o:', error);
      });
    };

    window.addEventListener('admin-activated', handleAdminActivated as EventListener);
    window.addEventListener('company-created', handleCompanyCreated as EventListener);
    
    return () => {
      window.removeEventListener('admin-activated', handleAdminActivated as EventListener);
      window.removeEventListener('company-created', handleCompanyCreated as EventListener);
    };
  }, [fetchCompanies]);

  const startPolling = useCallback(() => {
    if (isPolling) return;
    
    setIsPolling(true);
    const interval = setInterval(() => {
      console.log('üîÑ [useCompanies] Polling - atualizando dados...');
      fetchCompanies();
    }, 45000); // ‚úÖ OTIMIZADO: Intervalo aumentado para 45s (melhor performance)
    
    setTimeout(() => {
      clearInterval(interval);
      setIsPolling(false);
      console.log('‚èπÔ∏è [useCompanies] Polling parado');
    }, 3 * 60 * 1000); // ‚úÖ OTIMIZADO: Polling reduzido para 3min (economia de recursos)
    
    return () => clearInterval(interval);
  }, [fetchCompanies, isPolling]);

  return {
    companies,
    loading,
    error,
    fetchCompanies,
    toggleCompanyStatus,
    deleteCompany,
    resendActivationEmail,
    refetch: fetchCompanies,
    startPolling
  };
}; 
