import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '../providers/AuthProvider';
import RoleBasedMenu from './RoleBasedMenu';
import CRMLayout from './CRMLayout';
import { usePipelineSubHeader, useLeadsSubHeader } from '../hooks/useSubHeaderContent';
import { usePipelineData } from '../hooks/usePipelineData';
import { usePipelineCache } from '../hooks/usePipelineCache'; // ‚úÖ FASE 2: Importar cache inteligente
import PipelineSpecificSubHeader from './SubHeader/PipelineSpecificSubHeader';
import EmpresasSubHeader from './SubHeader/EmpresasSubHeader';
import { logger } from '../utils/logger';
import { CheckCircle, Users, BarChart3, Settings, X } from 'lucide-react';

const AppDashboard: React.FC = () => {
  const { user, logout } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  const { pipelines, loading: pipelinesLoading, refreshPipelines } = usePipelineData();
  
  // üöÄ ESTADO LOCAL: Para atualiza√ß√µes imediatas do dropdown
  const [localPipelines, setLocalPipelines] = useState(pipelines);
  
  // ‚úÖ THROTTLING: Ref para controlar logs duplicados
  const lastLoggedPipeline = useRef<string | null>(null);
  const lastSubHeaderLogTime = useRef<number>(0);
  
  // ‚úÖ OTIMIZA√á√ÉO: useEffect otimizado com verifica√ß√£o de mudan√ßa real
  useEffect(() => {
    if (pipelines !== localPipelines) {
      setLocalPipelines(pipelines);
    }
  }, [pipelines, localPipelines]);
  
  // üéØ SUBHEADER: Pipelines reais filtradas por tenant do usu√°rio (MOVIDO PARA CIMA)
  const userPipelines = useMemo(() => {
    if (pipelinesLoading || !user || !localPipelines) return [];
    
    // Filtrar pipelines do tenant do usu√°rio
    return localPipelines.filter(pipeline => pipeline.tenant_id === user.tenant_id);
  }, [localPipelines, user, pipelinesLoading]);
  
  // ‚ö° LISTENER: Atualiza√ß√£o imediata do dropdown ap√≥s arquivamento
  useEffect(() => {
    const handlePipelineArchiveUpdate = (event: CustomEvent) => {
      const { pipelineId, is_archived, archived_at } = event.detail;
      
      // ‚úÖ CORRE√á√ÉO: Log apenas em desenvolvimento com throttling
      if (import.meta.env.DEV) {
        console.log(`‚ö° [AppDashboard] Recebeu atualiza√ß√£o imediata:`, {
          pipelineId,
          is_archived,
          archived_at,
          localPipelinesLength: localPipelines?.length || 0
        });
      }
      
      // Atualizar pipeline espec√≠fica no array local imediatamente
      setLocalPipelines(prevPipelines => {
        if (!prevPipelines) return prevPipelines;
        
        return prevPipelines.map(pipeline => {
          if (pipeline.id === pipelineId) {
            const updated = {
              ...pipeline,
              is_archived,
              archived_at,
              is_active: !is_archived // Manter consist√™ncia
            };
            
            // ‚úÖ CORRE√á√ÉO: Log apenas em desenvolvimento
            if (import.meta.env.DEV) {
              console.log(`üéØ [AppDashboard] Pipeline atualizada no dropdown:`, {
                name: pipeline.name,
                before: { is_archived: pipeline.is_archived, archived_at: pipeline.archived_at },
                after: { is_archived: updated.is_archived, archived_at: updated.archived_at }
              });
            }
            
            return updated;
          }
          return pipeline;
        });
      });
    };

    window.addEventListener('pipeline-archive-updated', handlePipelineArchiveUpdate as EventListener);
    
    return () => {
      window.removeEventListener('pipeline-archive-updated', handlePipelineArchiveUpdate as EventListener);
    };
  }, [localPipelines]);
  
  
  // üîÑ CORRE√á√ÉO PONTUAL: Listener para pipeline duplicada - atualiza√ß√£o imediata do dropdown
  useEffect(() => {
    const handlePipelineDuplicated = (event: CustomEvent) => {
      const { pipeline } = event.detail;
      
      console.log('üîÑ [CORRE√á√ÉO-DROPDOWN] Pipeline duplicada recebida:', {
        name: pipeline.name,
        id: pipeline.id.substring(0, 8),
        localPipelinesLength: localPipelines?.length || 0
      });
      
      // Adicionar nova pipeline ao estado local imediatamente
      setLocalPipelines(prevPipelines => {
        if (!prevPipelines) return [pipeline];
        
        // Verificar se j√° existe para evitar duplicatas
        const exists = prevPipelines.find(p => p.id === pipeline.id);
        if (exists) {
          console.log('üîÑ [CORRE√á√ÉO-DROPDOWN] Pipeline j√° existe, pulando adi√ß√£o');
          return prevPipelines;
        }
        
        // Adicionar no in√≠cio da lista (mais recente primeiro)
        const updated = [pipeline, ...prevPipelines];
        
        console.log('‚úÖ [CORRE√á√ÉO-DROPDOWN] Pipeline adicionada ao dropdown imediatamente:', {
          name: pipeline.name,
          totalPipelines: updated.length,
          action: 'immediate-local-update'
        });
        
        return updated;
      });
    };

    window.addEventListener('pipeline-duplicated', handlePipelineDuplicated as EventListener);
    
    return () => {
      window.removeEventListener('pipeline-duplicated', handlePipelineDuplicated as EventListener);
    };
  }, [localPipelines]);
  
  // üéâ DETEC√á√ÉO: Verificar se √© um admin rec√©m-ativado (CORRE√á√ÉO CR√çTICA #3)
  const [showWelcomeMessage, setShowWelcomeMessage] = useState(false);
  const [welcomeData, setWelcomeData] = useState<{
    message: string;
    isNewActivation: boolean;
    autoLoginAttempts?: number;
    tokensStored?: boolean;
    activationMethod?: 'location' | 'event';
  } | null>(null);
  
  // üîÑ PERSIST√äNCIA: Recuperar m√≥dulo ativo do localStorage ou usar padr√£o baseado no role
  const getDefaultModule = (userRole: string) => {
    switch (userRole) {
      case 'super_admin':
        return 'Relat√≥rio';
      case 'admin':
        return 'Dashboard Admin';
      case 'member':
        return 'Meu Dashboard';
      default:
        return 'Dashboard Admin';
    }
  };

  // üìã VALIDA√á√ÉO: M√≥dulos v√°lidos por role
  const getValidModulesForRole = (userRole: string): string[] => {
    switch (userRole) {
      case 'super_admin':
        return ['Relat√≥rio', 'Feedback', 'Clientes', 'Configura√ß√µes da Plataforma', 'Notifica√ß√µes'];
      case 'admin':
        return ['Dashboard Admin', 'Vendedores', 'Gest√£o de pipeline', 'Gest√£o de formul√°rios', 'Acompanhamento', 'Leads', 'Integra√ß√µes'];
      case 'member':
        return ['Meu Dashboard', 'Pipeline', 'Gest√£o de pipeline', 'Leads', 'Acompanhamento'];
      default:
        return ['Dashboard Admin'];
    }
  };

  // üîç VALIDA√á√ÉO: Verificar se m√≥dulo salvo √© v√°lido para o role atual
  const isModuleValidForRole = (moduleName: string, userRole: string): boolean => {
    const validModules = getValidModulesForRole(userRole);
    return validModules.includes(moduleName);
  };

  // üîÑ PERSIST√äNCIA: Estado com recupera√ß√£o autom√°tica otimizada
  const [activeModule, setActiveModule] = useState(() => {
    // Durante a inicializa√ß√£o, usar um valor padr√£o tempor√°rio
    // O valor correto ser√° definido no useEffect quando o user estiver dispon√≠vel
    return 'Dashboard Admin';
  });

  // üéØ INTEGRA√á√ïES: Estado para gerenciar aba ativa das integra√ß√µes
  const [integrationsActiveTab, setIntegrationsActiveTab] = useState<'config' | 'calendar' | 'email'>('config');

  // üÜï VENDEDORES: Estado para SubHeader din√¢mico renderizado por m√≥dulos
  const [dynamicSubHeaderContent, setDynamicSubHeaderContent] = useState<React.ReactNode>(null);

  // üÜï VENDEDORES: Fun√ß√£o para renderizar SubHeader dinamicamente
  const renderSubHeader = useCallback((subHeaderContent: React.ReactNode) => {
    console.log('üéØ [AppDashboard] renderSubHeader chamado:', {
      hasContent: !!subHeaderContent,
      contentType: typeof subHeaderContent,
      isNull: subHeaderContent === null,
      timestamp: new Date().toISOString()
    });
    setDynamicSubHeaderContent(subHeaderContent);
  }, []);

  // üîÑ PERSIST√äNCIA: Salvar m√≥dulo ativo sempre que mudar (useCallback para evitar re-renders)
  const handleNavigateWithPersistence = useCallback((moduleName: string) => {
    console.log(`üìç Navegando para: ${moduleName}`);
    
    try {
      // üéØ NOVO: Verificar se h√° query parameters (para Integra√ß√µes)
      let actualModuleName = moduleName;
      let queryParams: URLSearchParams | undefined;
      
      if (moduleName.includes('?')) {
        const [module, queryString] = moduleName.split('?');
        actualModuleName = module;
        queryParams = new URLSearchParams(queryString);
        
        // Se for Integra√ß√µes com par√¢metro tab, atualizar estado da aba
        if (actualModuleName === 'Integra√ß√µes' && queryParams.has('tab')) {
          const tabParam = queryParams.get('tab') as 'config' | 'calendar' | 'email';
          if (['config', 'calendar', 'email'].includes(tabParam)) {
            setIntegrationsActiveTab(tabParam);
            console.log(`üéØ Aba de integra√ß√µes definida: ${tabParam}`);
          }
        }
      }
      
      // Salvar no localStorage apenas o nome do m√≥dulo (sem query params)
      localStorage.setItem('crm_active_module', actualModuleName);
      
      // Atualizar estado do m√≥dulo ativo
      setActiveModule(actualModuleName);
      
      console.log(`‚úÖ M√≥dulo '${actualModuleName}' salvo com sucesso${queryParams ? ` (com par√¢metros)` : ''}`);
    } catch (error) {
      console.error('Erro ao salvar m√≥dulo ativo:', error);
      // Mesmo com erro, atualizar o estado
      const actualModuleName = moduleName.includes('?') ? moduleName.split('?')[0] : moduleName;
      setActiveModule(actualModuleName);
    }
  }, []);

  // ‚úÖ FASE 2: Cache inteligente de pipeline para acesso direto 
  const { 
    lastViewedPipeline, 
    setLastViewedPipeline, 
    clearCache,
    isLoading: cacheLoading 
  } = usePipelineCache({
    tenantId: user?.tenant_id || '',
    pipelines: userPipelines, // ‚úÖ CORRIGIDO: Agora userPipelines est√° definido antes
    fallbackToPipelineId: undefined // Pode ser usado para pipeline espec√≠fica
  });

  // ‚ö° LISTENER: Atualiza√ß√£o instant√¢nea quando pipeline √© editada (MOVIDO AP√ìS usePipelineCache)
  useEffect(() => {
    const handlePipelineUpdated = (event: CustomEvent) => {
      const { pipeline, source, timestamp } = event.detail;
      
      console.log('‚ö° [AppDashboard] Pipeline atualizada - for√ßando atualiza√ß√£o instant√¢nea:', {
        name: pipeline.name,
        description: pipeline.description,
        source,
        timestamp
      });
      
      // ‚úÖ For√ßar atualiza√ß√£o do lastViewedPipeline se for a mesma
      if (lastViewedPipeline && lastViewedPipeline.id === pipeline.id) {
        setLastViewedPipeline(pipeline);
        console.log('‚ö° [AppDashboard] LastViewedPipeline sincronizada instantaneamente');
      }
      
      // ‚úÖ For√ßar refresh das pipelines para atualizar SubHeader
      refreshPipelines();
    };

    window.addEventListener('pipeline-updated', handlePipelineUpdated as EventListener);
    
    return () => {
      window.removeEventListener('pipeline-updated', handlePipelineUpdated as EventListener);
    };
  }, [lastViewedPipeline, setLastViewedPipeline, refreshPipelines]);

  // üéØ SUBHEADER: Estados para m√≥dulo de Pipelines
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedFilter, setSelectedFilter] = useState<'all' | 'active' | 'archived'>('active');
  
  // üéØ SUBHEADER: Estados para visualiza√ß√£o de pipeline simplificados
  const [pipelineSearchTerm, setPipelineSearchTerm] = useState('');

  // üéØ SUBHEADER: Estados para m√≥dulo de Leads
  const [leadsSearchTerm, setLeadsSearchTerm] = useState('');
  const [leadsSelectedFilter, setLeadsSelectedFilter] = useState<'all' | 'assigned' | 'not_assigned' | 'without_opportunity'>('all');
  const [leadsData, setLeadsData] = useState<any[]>([]);
  const [leadsWithOpportunities, setLeadsWithOpportunities] = useState<Set<string>>(new Set());

  // üéØ SUBHEADER: Estados para m√≥dulo de Empresas/Clientes
  const [empresasSearchTerm, setEmpresasSearchTerm] = useState('');
  const [empresasFilters, setEmpresasFilters] = useState({ 
    status: 'all', 
    industry: 'all', 
    adminStatus: 'all' 
  });
  const [empresasData, setEmpresasData] = useState<any[]>([]);

  // üóëÔ∏è REMOVIDO: Declara√ß√£o duplicada de integrationsActiveTab (j√° definida acima)

  // ‚úÖ REMOVIDO: userPipelines j√° definido no topo do componente

  // üéØ SUBHEADER: Handlers para Pipelines
  const handleSearchChange = useCallback((value: string) => {
    setSearchTerm(value);
  }, []);

  const handleFilterChange = useCallback((filterId: string) => {
    setSelectedFilter(filterId as 'all' | 'active' | 'archived');
  }, []);

  const handleCreatePipeline = useCallback(() => {
    console.log('üéØ [AppDashboard] Solicitando cria√ß√£o de nova pipeline via evento');
    
    // Enviar evento customizado para comunicar com o componente de pipeline
    const createPipelineEvent = new CustomEvent('pipeline-create-requested', {
      detail: {
        timestamp: new Date().toISOString(),
        source: 'subheader-button'
      }
    });
    
    window.dispatchEvent(createPipelineEvent);
  }, []);

  // üéØ SUBHEADER: Handlers para Leads
  const handleLeadsSearchChange = useCallback((value: string) => {
    setLeadsSearchTerm(value);
  }, []);

  const handleLeadsFilterChange = useCallback((filterId: string) => {
    setLeadsSelectedFilter(filterId as 'all' | 'assigned' | 'not_assigned' | 'without_opportunity');
  }, []);

  const handleCreateLead = useCallback(() => {
    console.log('üéØ [AppDashboard] Solicitando cria√ß√£o de novo lead via evento');
    
    // Enviar evento customizado para comunicar com o componente de leads
    const createLeadEvent = new CustomEvent('lead-create-requested', {
      detail: {
        timestamp: new Date().toISOString(),
        source: 'subheader-button'
      }
    });
    
    window.dispatchEvent(createLeadEvent);
  }, []);

  // üóëÔ∏è REMOVIDO: handleIntegrationsTabChange (controle agora √© via header dropdown)

  const handleImportLeads = useCallback(() => {
    console.log('üì• [AppDashboard] Solicitando importa√ß√£o de leads via evento');
    
    const importLeadsEvent = new CustomEvent('leads-import-requested', {
      detail: {
        timestamp: new Date().toISOString(),
        source: 'subheader-menu'
      }
    });
    
    window.dispatchEvent(importLeadsEvent);
  }, []);

  const handleExportLeads = useCallback(() => {
    console.log('üì§ [AppDashboard] Solicitando exporta√ß√£o de leads via evento');
    
    const exportLeadsEvent = new CustomEvent('leads-export-requested', {
      detail: {
        timestamp: new Date().toISOString(),
        source: 'subheader-menu'
      }
    });
    
    window.dispatchEvent(exportLeadsEvent);
  }, []);

  // üéØ SUBHEADER: Handlers para m√≥dulo de Empresas/Clientes
  const handleEmpresasSearchChange = useCallback((value: string) => {
    setEmpresasSearchTerm(value);
    
    // ‚úÖ COMUNICA√á√ÉO: Enviar mudan√ßa de busca para EmpresasModule
    const empresasFiltersEvent = new CustomEvent('empresas-filters-updated', {
      detail: {
        searchTerm: value,
        filters: empresasFilters, // Manter filtros atuais
        timestamp: new Date().toISOString()
      }
    });
    window.dispatchEvent(empresasFiltersEvent);
  }, [empresasFilters]);

  const handleEmpresasFiltersChange = useCallback((filters: any) => {
    // ‚úÖ CORRE√á√ÉO: Separar searchTerm dos outros filtros
    if (filters.searchTerm !== undefined) {
      setEmpresasSearchTerm(filters.searchTerm);
    }
    
    // Atualizar apenas os filtros (status, industry, adminStatus)
    setEmpresasFilters({
      status: filters.status || 'all',
      industry: filters.industry || 'all', 
      adminStatus: filters.adminStatus || 'all'
    });
    
    // ‚úÖ COMUNICA√á√ÉO: Enviar filtros para EmpresasModule via Custom Events
    const empresasFiltersEvent = new CustomEvent('empresas-filters-updated', {
      detail: {
        searchTerm: filters.searchTerm || '',
        filters: {
          status: filters.status || 'all',
          industry: filters.industry || 'all', 
          adminStatus: filters.adminStatus || 'all'
        },
        timestamp: new Date().toISOString()
      }
    });
    window.dispatchEvent(empresasFiltersEvent);
  }, []);

  const handleCreateCompany = useCallback(() => {
    console.log('üéØ [AppDashboard] Solicitando cria√ß√£o de nova empresa via evento');
    
    const createCompanyEvent = new CustomEvent('company-create-requested', {
      detail: {
        timestamp: new Date().toISOString(),
        source: 'subheader'
      }
    });
    
    window.dispatchEvent(createCompanyEvent);
  }, []);

  const handleRefreshCompanies = useCallback(() => {
    console.log('üîÑ [AppDashboard] Solicitando atualiza√ß√£o de empresas via evento');
    
    const refreshCompaniesEvent = new CustomEvent('companies-refresh-requested', {
      detail: {
        timestamp: new Date().toISOString(),
        source: 'subheader'
      }
    });
    
    window.dispatchEvent(refreshCompaniesEvent);
  }, []);

  // ‚úÖ FASE 4: Handlers para pipeline management no subheader
  const handleCreatePipelineFromSubHeader = useCallback(() => {
    console.log('‚ûï [AppDashboard] Criando nova pipeline via subheader');
    
    const createPipelineEvent = new CustomEvent('pipeline-create-requested', {
      detail: {
        timestamp: new Date().toISOString(),
        source: 'subheader-dropdown'
      }
    });
    
    window.dispatchEvent(createPipelineEvent);
  }, []);

  const handleEditPipelineFromSubHeader = useCallback((pipeline: any) => {
    console.log('‚úèÔ∏è [AppDashboard] Editando pipeline via subheader:', pipeline.name);
    
    const editPipelineEvent = new CustomEvent('pipeline-edit-requested', {
      detail: {
        pipeline,
        timestamp: new Date().toISOString(),
        source: 'subheader-dropdown'
      }
    });
    
    window.dispatchEvent(editPipelineEvent);
  }, []);

  const handleArchivePipelineFromSubHeader = useCallback((pipeline: any) => {
    console.log('üìÅ [AppDashboard] Arquivando pipeline via subheader:', pipeline.name);
    
    const archivePipelineEvent = new CustomEvent('pipeline-archive-requested', {
      detail: {
        pipelineId: pipeline.id,
        shouldArchive: true,
        pipeline,
        timestamp: new Date().toISOString(),
        source: 'subheader-dropdown'
      }
    });
    
    window.dispatchEvent(archivePipelineEvent);
  }, []);

  const handleUnarchivePipelineFromSubHeader = useCallback((pipeline: any) => {
    console.log('üìÇ [AppDashboard] Desarquivando pipeline via subheader:', pipeline.name);
    
    const unarchivePipelineEvent = new CustomEvent('pipeline-archive-requested', {
      detail: {
        pipelineId: pipeline.id,
        shouldArchive: false,
        pipeline,
        timestamp: new Date().toISOString(),
        source: 'subheader-dropdown'
      }
    });
    
    window.dispatchEvent(unarchivePipelineEvent);
  }, []);

  // üéØ SUBHEADER: Gerar conte√∫do do subheader baseado no m√≥dulo ativo
  const pipelinesToShow = useMemo(() => 
    activeModule === 'Gest√£o de pipeline' ? userPipelines : [], 
    [activeModule, userPipelines]
  );

  const pipelineSubHeaderContent = usePipelineSubHeader({
    pipelines: pipelinesToShow,
    searchTerm,
    selectedFilter,
    onSearchChange: handleSearchChange,
    onFilterChange: handleFilterChange,
    onCreatePipeline: handleCreatePipeline
  });

  const leadsSubHeaderContent = useLeadsSubHeader({
    leads: leadsData,
    leadsWithOpportunities: leadsWithOpportunities,
    searchTerm: leadsSearchTerm,
    selectedFilter: leadsSelectedFilter,
    onSearchChange: handleLeadsSearchChange,
    onFilterChange: handleLeadsFilterChange,
    onCreateLead: handleCreateLead,
    onImportClick: handleImportLeads,
    onExportClick: handleExportLeads
  });


  // üóëÔ∏è REMOVIDO: useIntegrationsSubHeader (controle de abas agora √© via header dropdown)
  

  // ‚úÖ FASE 2: Pipeline espec√≠fico simplificado - APENAS cache inteligente para acesso direto
  const pipelineSpecificSubHeader = useMemo(() => {
    // ‚úÖ CORRE√á√ÉO CR√çTICA: S√≥ executar para m√≥dulos de Pipeline
    if (activeModule !== 'Pipeline' && activeModule !== 'Gest√£o de pipeline') {
      return null;
    }
    
    // Aguardar carregamento do cache e pipelines
    if (cacheLoading || pipelinesLoading || !user) {
      return null;
    }

    // ‚úÖ CORRE√á√ÉO: L√ìGICA UNIFICADA - Sempre mostrar SubHeader para admins, mesmo sem pipelines
    // Para admins: sempre mostrar SubHeader para permitir cria√ß√£o da primeira pipeline
    const isAdmin = user.role === 'admin' || user.role === 'super_admin';
    
    if (userPipelines.length > 0) {
      // ‚úÖ AGUARDAR: Cache deve estar completamente carregado
      if (cacheLoading) {
        console.log('‚è≥ [AppDashboard] Aguardando cache carregar antes de criar SubHeader');
        return null; // Aguarda cache carregar para evitar conflitos de inicializa√ß√£o
      }
      
      // ‚úÖ DECIS√ÉO INTELIGENTE: Cache v√°lido > primeira dispon√≠vel
      const pipeline = lastViewedPipeline && userPipelines.find(p => p.id === lastViewedPipeline.id) 
        ? lastViewedPipeline 
        : userPipelines[0];
      
      if (!pipeline) {
        console.warn('üéØ [AppDashboard] Nenhuma pipeline dispon√≠vel para acesso direto');
        return null;
      }
      
      // ‚úÖ THROTTLING: Log apenas se pipeline mudou para reduzir spam
      const pipelineLogKey = `subheader-${pipeline.id}`;
      if (!lastLoggedPipeline.current || lastLoggedPipeline.current !== pipeline.id) {
        console.log('üéØ [AppDashboard] Criando SubHeader com cache inteligente unificado:', {
          pipelineId: pipeline.id,
          pipelineName: pipeline.name,
          activeModule,
          userRole: user.role,
          fromCache: !!lastViewedPipeline,
          cacheMatched: lastViewedPipeline?.id === pipeline.id,
          totalPipelines: userPipelines.length,
          logic: 'unified-cache-direct'
        });
        lastLoggedPipeline.current = pipeline.id;
      }
      
      return (
        <PipelineSpecificSubHeader
          selectedPipeline={pipeline}
          pipelines={userPipelines}
          isLoading={pipelinesLoading}
          onPipelineChange={(newPipeline) => {
            console.log('üîÑ [AppDashboard] Pipeline alterada pelo usu√°rio via SubHeader:', {
              from: pipeline.id,
              to: newPipeline.id,
              userRole: user.role,
              action: 'user-selection'
            });
            
            // ‚úÖ IMEDIATO: Salvar no cache (sempre respeitar escolha do usu√°rio)
            setLastViewedPipeline(newPipeline as any);
            
            // ‚úÖ EVENTO: Notificar componentes filhos sobre a mudan√ßa
            window.dispatchEvent(new CustomEvent('pipeline-view-changed', { 
              detail: { 
                pipeline: newPipeline,
                source: 'user-selection-subheader',
                userRole: user.role
              } 
            }));
          }}
          onSearchChange={(value) => {
            setPipelineSearchTerm(value);
            window.dispatchEvent(new CustomEvent('pipeline-search-changed', {
              detail: { searchTerm: value }
            }));
          }}
          onDateRangeChange={(dateRange) => {
            console.log('üóìÔ∏è [AppDashboard] Filtro de data alterado:', dateRange);
            window.dispatchEvent(new CustomEvent('pipeline-date-filter-changed', {
              detail: { dateRange }
            }));
          }}
          onCreateOpportunity={() => {
            console.log('‚ûï [AppDashboard] Solicita√ß√£o de cria√ß√£o de oportunidade');
            window.dispatchEvent(new CustomEvent('create-opportunity-requested', {
              detail: { 
                pipelineId: pipeline.id,
                timestamp: new Date().toISOString()
              }
            }));
          }}
          // ‚úÖ FASE 4: Novos handlers para pipeline management
          onCreatePipeline={handleCreatePipelineFromSubHeader}
          onEditPipeline={handleEditPipelineFromSubHeader}
          onArchivePipeline={handleArchivePipelineFromSubHeader}
          onUnarchivePipeline={handleUnarchivePipelineFromSubHeader}
          searchValue={pipelineSearchTerm}
          searchPlaceholder="Buscar oportunidades, leads..."
        />
      );
    }
    
    // ‚úÖ CORRE√á√ÉO: Para admins sem pipelines, mostrar SubHeader vazio para permitir cria√ß√£o
    if (isAdmin && userPipelines.length === 0) {
      // ‚úÖ OTIMIZA√á√ÉO: Log com throttling para evitar spam (apenas uma vez por 5 segundos)
      const now = Date.now();
      if (process.env.NODE_ENV === 'development' && (now - lastSubHeaderLogTime.current >= 5000)) {
        lastSubHeaderLogTime.current = now;
        console.log('üéØ [AppDashboard] Criando SubHeader vazio para admin sem pipelines:', {
          activeModule,
          userRole: user.role,
          userPipelinesLength: userPipelines.length,
          logic: 'admin-empty-state'
        });
      }
      
      return (
        <PipelineSpecificSubHeader
          selectedPipeline={null}
          pipelines={[]}
          isLoading={pipelinesLoading}
          onPipelineChange={() => {}}
          onCreateOpportunity={() => {}}
          onCreatePipeline={handleCreatePipelineFromSubHeader}
          onEditPipeline={handleEditPipelineFromSubHeader}
          onArchivePipeline={handleArchivePipelineFromSubHeader}
          onUnarchivePipeline={handleUnarchivePipelineFromSubHeader}
          searchValue={pipelineSearchTerm}
          searchPlaceholder="Buscar oportunidades, leads..."
          showEmptyState={true}
        />
      );
    }
    
    // Caso sem pipeline dispon√≠vel ou contexto inv√°lido (somente para members)
    console.log('üéØ [AppDashboard] SubHeader n√£o ser√° criado:', {
      activeModule,
      userPipelinesLength: userPipelines.length,
      cacheLoading,
      pipelinesLoading,
      hasUser: !!user,
      userRole: user.role,
      logic: 'no-pipeline-context'
    });
    
    return null;
  }, [
    // ‚úÖ CORRE√á√ÉO: DEPEND√äNCIAS OTIMIZADAS - removidas fun√ß√µes est√°veis
    userPipelines, 
    pipelineSearchTerm, 
    activeModule,
    lastViewedPipeline,
    // setLastViewedPipeline removida - fun√ß√£o est√°vel do useCallback
    cacheLoading,
    pipelinesLoading,
    user,
    // ‚úÖ FASE 4: Incluir novos handlers
    handleCreatePipelineFromSubHeader,
    handleEditPipelineFromSubHeader,
    handleArchivePipelineFromSubHeader,
    handleUnarchivePipelineFromSubHeader
  ]);

  // ‚úÖ CORRE√á√ÉO CR√çTICA: SubHeader estabilizado para resolver re-renders consecutivos
  // PROBLEMA ORIGINAL: useMemo com muitas depend√™ncias inst√°veis causava re-renders
  // SOLU√á√ÉO: Estabilizar depend√™ncias com useMemo individuais e useCallback otimizado
  const empresasSubHeaderMemoized = useMemo(() => {
    if (activeModule !== 'Clientes') return null;
    
    return React.createElement(EmpresasSubHeader, {
      searchValue: empresasSearchTerm,
      onSearchChange: handleEmpresasSearchChange,
      filters: {
        searchTerm: empresasSearchTerm,
        status: empresasFilters.status,
        industry: empresasFilters.industry,
        adminStatus: empresasFilters.adminStatus
      },
      onFiltersChange: handleEmpresasFiltersChange,
      onCreateCompany: handleCreateCompany,
      onRefresh: handleRefreshCompanies,
      loading: false
    });
  }, [
    activeModule,
    empresasSearchTerm,
    empresasFilters.status,
    empresasFilters.industry,
    empresasFilters.adminStatus,
    handleEmpresasSearchChange,
    handleEmpresasFiltersChange,
    handleCreateCompany,
    handleRefreshCompanies
  ]);

  const subHeaderContent = useMemo(() => {
    const result = (() => {
      switch (activeModule) {
        case 'Gest√£o de pipeline':
          return pipelineSpecificSubHeader;
        case 'Pipeline':
          return pipelineSpecificSubHeader;
        case 'Leads':
          return leadsSubHeaderContent;
        case 'Clientes':
          return empresasSubHeaderMemoized;
        case 'Vendedores':
          return dynamicSubHeaderContent;
        case 'Integra√ß√µes':
          return undefined;
        default:
          return undefined;
      }
    })();
    
    // üö® DEBUG TEMPOR√ÅRIO: Logar resultado do subHeaderContent
    console.log('üìä [AppDashboard] subHeaderContent calculated:', {
      activeModule,
      hasResult: !!result,
      resultType: typeof result,
      isDynamicContent: activeModule === 'Vendedores',
      dynamicContent: !!dynamicSubHeaderContent,
      timestamp: new Date().toISOString()
    });
    
    return result;
  }, [
    activeModule,
    pipelineSpecificSubHeader,
    leadsSubHeaderContent,
    empresasSubHeaderMemoized,
    dynamicSubHeaderContent
  ]);

  // üéâ CORRE√á√ÉO CR√çTICA #3: Detec√ß√£o melhorada de admins rec√©m-ativados
  useEffect(() => {
    // üìç M√âTODO 1: Detec√ß√£o via location.state (redirecionamento direto)
    if (location.state?.isNewActivation && location.state?.welcomeMessage) {
      console.log('üéâ [CRITICAL-FIX-3] Admin rec√©m-ativado detectado via location.state');
      setWelcomeData({
        message: location.state.welcomeMessage,
        isNewActivation: location.state.isNewActivation,
        autoLoginAttempts: location.state.autoLoginAttempts || 1,
        activationMethod: 'location'
      });
      setShowWelcomeMessage(true);
      
      // Limpar o state da location para evitar mostrar novamente
      navigate('/dashboard', { replace: true });
    }
  }, [location.state, navigate]);

  // üéß CORRE√á√ÉO CR√çTICA #3: Listener para evento admin-activated
  useEffect(() => {
    const handleAdminActivated = (event: CustomEvent) => {
      console.log('üéâ [CRITICAL-FIX-3] Evento admin-activated recebido:', event.detail);
      
      const { adminEmail, tokensStored, attempt } = event.detail;
      
      // Verificar se √© o usu√°rio atual
      if (user && user.email === adminEmail) {
        console.log('‚úÖ [CRITICAL-FIX-3] Evento corresponde ao usu√°rio atual, exibindo boas-vindas');
        
        setWelcomeData({
          message: `Bem-vindo ao CRM! Sua conta foi ativada com sucesso e voc√™ foi logado automaticamente.`,
          isNewActivation: true,
          autoLoginAttempts: attempt,
          tokensStored: tokensStored,
          activationMethod: 'event'
        });
        setShowWelcomeMessage(true);
      } else {
        console.log('‚ÑπÔ∏è [CRITICAL-FIX-3] Evento n√£o corresponde ao usu√°rio atual, ignorando');
      }
    };

    // Registrar listener
    window.addEventListener('admin-activated', handleAdminActivated as EventListener);
    console.log('üéß [CRITICAL-FIX-3] Listener admin-activated registrado');

    // Cleanup
    return () => {
      window.removeEventListener('admin-activated', handleAdminActivated as EventListener);
      console.log('üßπ [CRITICAL-FIX-3] Listener admin-activated removido');
    };
  }, [user?.email]);

  // üéß Listener para receber dados de leads do LeadsModule
  useEffect(() => {
    const handleLeadsDataUpdated = (event: CustomEvent) => {
      console.log('üìä [AppDashboard] Dados de leads recebidos:', event.detail);
      setLeadsData(event.detail.leads || []);
      
      // üéØ Converter array de volta para Set
      if (event.detail.leadsWithOpportunities) {
        setLeadsWithOpportunities(new Set(event.detail.leadsWithOpportunities));
        console.log('üéØ [AppDashboard] leadsWithOpportunities recebido:', event.detail.leadsWithOpportunities.length, 'leads com oportunidades');
      }
    };

    // Registrar listener
    window.addEventListener('leads-data-updated', handleLeadsDataUpdated as EventListener);
    console.log('üéß [AppDashboard] Listener leads-data-updated registrado');

    // Cleanup
    return () => {
      window.removeEventListener('leads-data-updated', handleLeadsDataUpdated as EventListener);
      console.log('üßπ [AppDashboard] Listener leads-data-updated removido');
    };
  }, []);

  // üéß Listener para receber dados de empresas do EmpresasModule
  useEffect(() => {
    const handleEmpresasDataUpdated = (event: CustomEvent) => {
      console.log('üìä [AppDashboard] Dados de empresas recebidos:', event.detail);
      if (event.detail.companies) {
        setEmpresasData(event.detail.companies);
        console.log('üéØ [AppDashboard] empresasData atualizado:', event.detail.companies.length, 'empresas');
      }
    };

    // Registrar listener
    window.addEventListener('empresas-data-updated', handleEmpresasDataUpdated as EventListener);
    console.log('üéß [AppDashboard] Listener empresas-data-updated registrado');

    // Cleanup
    return () => {
      window.removeEventListener('empresas-data-updated', handleEmpresasDataUpdated as EventListener);
      console.log('üßπ [AppDashboard] Listener empresas-data-updated removido');
    };
  }, []);

  // ‚úÖ FASE 2: REMOVIDO - Listeners de pipeline-view-entered/exited causavam ciclo infinito
  // Agora usando apenas cache inteligente sem eventos conflitantes

  // üì° Enviar filtros de leads para o LeadsModule quando mudarem
  useEffect(() => {
    if (activeModule === 'Leads') {
      const leadsFiltersEvent = new CustomEvent('leads-filters-updated', {
        detail: {
          searchTerm: leadsSearchTerm,
          selectedFilter: leadsSelectedFilter,
          timestamp: new Date().toISOString()
        }
      });
      window.dispatchEvent(leadsFiltersEvent);
      console.log('üîç [AppDashboard] Filtros de leads enviados');
    }
  }, [leadsSearchTerm, leadsSelectedFilter, activeModule]);

  // ‚úÖ REMOVIDO: Custom Events desnecess√°rios - agora temos comunica√ß√£o direta via EmpresasSubHeader

  // üîÑ PERSIST√äNCIA: Sincronizar com mudan√ßas de usu√°rio (corrigido para evitar loop)
  useEffect(() => {
    if (user) {
      const savedModule = localStorage.getItem('crm_active_module');
      const defaultModule = getDefaultModule(user.role);
      
      if (import.meta.env.MODE === 'development') {
        console.log(`üîÑ Usu√°rio dispon√≠vel (${user.role})`);
        console.log(`üì¶ M√≥dulo salvo: ${savedModule || 'nenhum'}`);
        console.log(`üéØ M√≥dulo padr√£o para role: ${defaultModule}`);
      }
      
      // Verificar se o m√≥dulo salvo √© v√°lido para o role atual
      if (savedModule && isModuleValidForRole(savedModule, user.role)) {
        if (import.meta.env.MODE === 'development') {
          console.log(`‚úÖ M√≥dulo salvo '${savedModule}' √© v√°lido para role '${user.role}' - mantendo`);
        }
        setActiveModule(savedModule);
      } else {
        if (savedModule && import.meta.env.MODE === 'development') {
          console.log(`‚ö†Ô∏è M√≥dulo salvo '${savedModule}' n√£o √© v√°lido para role '${user.role}' - usando padr√£o`);
        }
        if (import.meta.env.MODE === 'development') {
          console.log(`üîÑ Definindo m√≥dulo padr√£o: ${defaultModule}`);
        }
        localStorage.setItem('crm_active_module', defaultModule);
        setActiveModule(defaultModule);
      }
    }
  }, [user?.id, user?.role]); // Depend√™ncias espec√≠ficas para evitar loops

  // üßπ LIMPEZA: Limpar m√≥dulo ativo no logout
  const handleLogout = async () => {
    try {
      logger.info('Iniciando processo de logout', 'AppDashboard');
      
      // Limpar m√≥dulo ativo do localStorage
      localStorage.removeItem('crm_active_module');
      console.log('üßπ M√≥dulo ativo limpo do localStorage');
      
      await logout();
      logger.info('Logout conclu√≠do, redirecionando', 'AppDashboard');
      navigate('/login');
    } catch (error) {
      logger.error('Erro durante logout', 'AppDashboard', error);
      // For√ßar redirecionamento mesmo em caso de erro
      window.location.href = '/login';
    }
  };

  // ‚úÖ CORRE√á√ÉO: useEffect separado para logging do SubHeader (evita side effects em useMemo)
  useEffect(() => {
    const now = Date.now();
    if (process.env.NODE_ENV === 'development' && (now - lastSubHeaderLogTime.current >= 5000)) {
      lastSubHeaderLogTime.current = now;
      console.log('üîç [AppDashboard] Selecionando SubHeader:', {
        activeModule,
        hasLeadsSubHeader: !!leadsSubHeaderContent,
        hasPipelineSubHeader: !!pipelineSpecificSubHeader,
        hasEmpresasSubHeader: !!empresasSubHeaderMemoized,
        hasDynamicSubHeader: !!dynamicSubHeaderContent
      });
    }
  }, [activeModule, leadsSubHeaderContent, pipelineSpecificSubHeader, empresasSubHeaderMemoized, dynamicSubHeaderContent]);

  // üéâ CORRE√á√ÉO CR√çTICA #3: Modal de boas-vindas melhorado para novos admins
  const WelcomeModal = () => {
    if (!showWelcomeMessage || !welcomeData) return null;

          return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4 animate-fade-in">
          <div className="bg-white rounded-2xl shadow-2xl max-w-lg w-full mx-4 overflow-hidden transform animate-fade-in-up">
          
          {/* Header */}
          <div className="bg-gradient-to-r from-green-500 to-blue-600 px-6 py-8 text-white text-center relative">
            <button
              onClick={() => {
                console.log('üîÑ [CRITICAL-FIX-3] Modal de boas-vindas fechado pelo usu√°rio');
                setShowWelcomeMessage(false);
              }}
              className="absolute top-4 right-4 text-white hover:text-gray-200 transition-colors"
            >
              <X className="w-5 h-5" />
            </button>
            <CheckCircle className="w-16 h-16 mx-auto mb-4 animate-bounce" />
            <h2 className="text-2xl font-bold">üéâ Bem-vindo ao CRM!</h2>
            <p className="text-green-100 mt-2">Sua conta foi ativada com sucesso</p>
          </div>

          {/* Content */}
          <div className="p-6">
            <div className="mb-6">
              <p className="text-gray-700 mb-4">
                {welcomeData.message}
              </p>
              <p className="text-sm text-gray-600 mb-4">
                Como administrador, voc√™ tem acesso a todas as funcionalidades do sistema.
              </p>
              
              {/* üîß CORRE√á√ÉO CR√çTICA #3: Informa√ß√µes contextuais de ativa√ß√£o */}
              {(welcomeData.autoLoginAttempts || welcomeData.tokensStored || welcomeData.activationMethod) && (
                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
                  <h4 className="font-medium text-blue-900 mb-2">‚ÑπÔ∏è Detalhes da Ativa√ß√£o</h4>
                  <div className="space-y-1 text-sm text-blue-700">
                    {welcomeData.activationMethod && (
                      <p>‚Ä¢ M√©todo: {welcomeData.activationMethod === 'event' ? 'Auto-detec√ß√£o por evento' : 'Redirecionamento direto'}</p>
                    )}
                    {welcomeData.autoLoginAttempts && (
                      <p>‚Ä¢ Login autom√°tico: Sucesso na {welcomeData.autoLoginAttempts}¬™ tentativa</p>
                    )}
                    {typeof welcomeData.tokensStored === 'boolean' && (
                      <p>‚Ä¢ Tokens de seguran√ßa: {welcomeData.tokensStored ? '‚úÖ Armazenados' : '‚ö†Ô∏è N√£o armazenados'}</p>
                    )}
                  </div>
                </div>
              )}
            </div>

            {/* üîß CORRE√á√ÉO CR√çTICA #3: Quick Actions melhorados */}
            <div className="space-y-3 mb-6">
              <h3 className="font-semibold text-gray-800 mb-3">üöÄ Primeiros passos recomendados:</h3>
              
              <button
                onClick={() => {
                  console.log('üéØ [CRITICAL-FIX-3] Quick action: Navegando para Vendedores');
                  setShowWelcomeMessage(false);
                  handleNavigateWithPersistence('Vendedores');
                }}
                className="w-full flex items-center space-x-3 p-3 bg-blue-50 hover:bg-blue-100 rounded-lg transition-all duration-200 hover:shadow-md text-left group"
              >
                <Users className="w-5 h-5 text-blue-600 group-hover:scale-110 transition-transform" />
                <div>
                  <p className="font-medium text-blue-900">Gerenciar Vendedores</p>
                  <p className="text-sm text-blue-700">Adicione e configure sua equipe de vendas</p>
                </div>
              </button>

              <button
                onClick={() => {
                  console.log('üéØ [CRITICAL-FIX-3] Quick action: Navegando para Pipeline');
                  setShowWelcomeMessage(false);
                  handleNavigateWithPersistence('Gest√£o de pipeline');
                }}
                className="w-full flex items-center space-x-3 p-3 bg-purple-50 hover:bg-purple-100 rounded-lg transition-all duration-200 hover:shadow-md text-left group"
              >
                <BarChart3 className="w-5 h-5 text-purple-600 group-hover:scale-110 transition-transform" />
                <div>
                  <p className="font-medium text-purple-900">Configurar Pipeline</p>
                  <p className="text-sm text-purple-700">Defina as etapas do seu processo de vendas</p>
                </div>
              </button>

              <button
                onClick={() => {
                  console.log('üéØ [CRITICAL-FIX-3] Quick action: Navegando para Integra√ß√µes');
                  setShowWelcomeMessage(false);
                  handleNavigateWithPersistence('Integra√ß√µes');
                }}
                className="w-full flex items-center space-x-3 p-3 bg-green-50 hover:bg-green-100 rounded-lg transition-all duration-200 hover:shadow-md text-left group"
              >
                <Settings className="w-5 h-5 text-green-600 group-hover:scale-110 transition-transform" />
                <div>
                  <p className="font-medium text-green-900">Configurar Integra√ß√µes</p>
                  <p className="text-sm text-green-700">Conecte suas ferramentas favoritas</p>
                </div>
              </button>
            </div>

            {/* üîß CORRE√á√ÉO CR√çTICA #3: Bot√£o principal melhorado */}
            <button
              onClick={() => {
                console.log('‚úÖ [CRITICAL-FIX-3] Modal de boas-vindas conclu√≠do - usu√°rio pronto para usar o CRM');
                setShowWelcomeMessage(false);
              }}
              className="w-full bg-gradient-to-r from-blue-600 to-purple-600 text-white py-3 rounded-lg font-medium hover:from-blue-700 hover:to-purple-700 transition-all duration-200 hover:shadow-lg transform hover:-translate-y-0.5"
            >
              ‚ú® Come√ßar a usar o CRM
            </button>
          </div>
        </div>
      </div>
    );
  };

  if (!user) {
    // ‚úÖ CORRE√á√ÉO: Em desenvolvimento, n√£o mostrar loading intrusivo
    if (import.meta.env.DEV) {
      return null;
    }
    
    // Em produ√ß√£o: loading minimal no canto superior direito
    return (
      <div className="fixed top-4 right-4 z-50">
        <div className="bg-white shadow-lg rounded-lg p-3 flex items-center space-x-2">
          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
          <span className="text-sm text-gray-700">Carregando...</span>
        </div>
      </div>
    );
  }

  return (
    <>
    <CRMLayout 
      user={user} 
      onLogout={handleLogout}
      activeModule={activeModule}
      onNavigate={handleNavigateWithPersistence}
      subHeaderContent={subHeaderContent}
    >
      <RoleBasedMenu 
        selectedItem={activeModule}
        userRole={user?.role || 'member'}
        searchTerm={searchTerm}
        selectedFilter={selectedFilter}
        // ‚úÖ CORRE√á√ÉO: Props de cache para UnifiedPipelineManager
        selectedPipeline={lastViewedPipeline}
        onPipelineChange={setLastViewedPipeline}
        cacheLoading={cacheLoading}
        // ‚úÖ INTEGRA√á√ÉO: Prop para controle de aba ativa das integra√ß√µes
        integrationsActiveTab={integrationsActiveTab}
        // üÜï VENDEDORES: Prop para renderizar SubHeader dinamicamente
        renderSubHeader={renderSubHeader}
      />
    </CRMLayout>
      
      {/* Modal de boas-vindas */}
      <WelcomeModal />
    </>
  );
};

export default AppDashboard;

